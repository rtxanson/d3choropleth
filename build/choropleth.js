// Generated by CoffeeScript 1.6.3
var Choropleth,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

$.fn.extend({
  d3choropleth: function(options) {
    var opts, self;
    self = $.fn.d3choropleth;
    opts = $.extend({}, self.default_options, options);
    return $(this).each(function(i, el) {
      self.init(el, opts);
      if (opts.log) {
        return self.log(el);
      }
    });
  }
});

$.extend($.fn.d3choropleth, {
  default_options: {
    height: 600,
    width: 450,
    log: true,
    boundary_json: "/d3choropleth/data/wards.topo.json",
    boundary_path: "wards.geo",
    boundary_label_property: "WARDS",
    boundary_id_field: "NAMEUPPER",
    boundary_shading_attribute: false,
    boundary_class_name: "ward",
    boundary_label_class_name: "place-label",
    shading_tsv: false,
    shading_tsv_id_field: false,
    shading_tsv_count_field: false,
    quantization_min: 70,
    quantization_max: 300,
    quantization_class_name: "q",
    additional_data: false
  },
  init: function(el, opts) {
    return this.svg = this.createSvg(el, opts);
  },
  createSvg: function(el, opts) {
    self.svg = new Choropleth(el, opts);
    window.svg = self.svg;
    if (opts.logs) {
      console.log("initialized");
      return console.log(self.svg.opts);
    }
  },
  log: function(msg) {
    return console.log(msg);
  }
});

Choropleth = (function() {
  Choropleth.prototype.rateByID = d3.map();

  function Choropleth(el, opts) {
    this.el = el;
    this.opts = opts;
    this.add_additional_datasources = __bind(this.add_additional_datasources, this);
    this.drawMap = __bind(this.drawMap, this);
    this.makeSvg();
  }

  Choropleth.prototype.make_bounds = function(topo) {
    var b, height, s, t, width;
    width = this.opts.width;
    height = this.opts.height;
    b = this.path.bounds(topo);
    s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height);
    t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];
    return [s, t];
  };

  Choropleth.prototype.makeSvg = function() {
    var q,
      _this = this;
    this.proj = d3.geo.mercator().scale(1).translate([0, 0]);
    this.path = d3.geo.path().projection(this.proj);
    q = queue().defer(d3.json, this.opts.boundary_json);
    if (this.opts.shading_tsv) {
      q.defer(d3.tsv, this.opts.shading_tsv, function(d) {
        var _k, _v;
        _k = d[_this.opts.shading_tsv_id_field];
        _v = d[_this.opts.shading_tsv_count_field];
        return _this.rateByID.set(_k, +_v);
      });
    }
    return q.await(this.drawMap);
  };

  Choropleth.prototype.drawMap = function(error, json) {
    var boundary_path, d, d_max, d_min, quanta, scale, translate, _i, _len, _prop_id, _ref, _ref1, _set_data_attribute_value, _set_quantized_class, _set_text_label_class, _transform_to_centroid_geom,
      _this = this;
    boundary_path = this.opts.boundary_path;
    this.topo = topojson.feature(json, json.objects[boundary_path]);
    this.features = this.topo.features;
    _ref = this.make_bounds(this.topo), scale = _ref[0], translate = _ref[1];
    this.proj.scale(scale).translate(translate);
    this.svg = d3.select(this.el).append("svg").attr("preserveAspectRatio", "xMinYMin meet");
    this.json = json;
    d_min = this.opts.quantization_min;
    d_max = this.opts.quantization_max;
    quanta = d3.scale.quantize().domain([d_min, d_max]).range(d3.range(9).map(function(i) {
      return _this.opts.quantization_class_name + i + "-9";
    }));
    if (this.opts.boundary_shading_attribute) {
      _ref1 = this.features;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        d = _ref1[_i];
        this.rateByID.set(d.id, d.properties[this.opts.boundary_shading_attribute]);
      }
    }
    _prop_id = this.opts.boundary_id_field;
    _set_quantized_class = function(d) {
      var _id_name;
      _id_name = d.properties[_prop_id];
      return "" + _this.opts.boundary_class_name + " " + (quanta(_this.rateByID.get(_id_name)));
    };
    _set_text_label_class = function(d) {
      var _id_name;
      _id_name = d.properties[_prop_id];
      return "" + _this.opts.boundary_label_class_name + " " + (quanta(_this.rateByID.get(_id_name)));
    };
    _set_data_attribute_value = function(d) {
      return d.properties[_prop_id];
    };
    this.svg.selectAll("path").data(this.features).enter().append("path").attr("class", _set_quantized_class).attr("data-" + this.opts.boundary_class_name, _set_data_attribute_value).attr("d", this.path);
    this.svg.selectAll("." + this.opts.boundary_class_name + "-border").data(this.features).enter().append("path").attr("class", "" + this.opts.boundary_class_name + "-border").attr("data-" + this.opts.boundary_class_name, _set_data_attribute_value).attr("d", this.path);
    _transform_to_centroid_geom = function(d) {
      return "translate(" + (_this.path.centroid(d.geometry)) + ")";
    };
    this.svg.selectAll(".place-label").data(this.features).enter().append("text").attr("class", _set_text_label_class).attr("transform", _transform_to_centroid_geom).attr("dy", ".35em").style("text-anchor", "middle").text(function(d) {
      return d.properties[_this.opts.boundary_label_property];
    });
    if (this.opts.additional_data) {
      return this.add_additional_datasources(error, json);
    }
  };

  Choropleth.prototype.add_additional_datasources = function(error, json) {
    var json_objs, source, _i, _len, _ref, _results;
    _ref = this.opts.additional_data;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      json_objs = json.objects[source.datum_path];
      _results.push(this.svg.selectAll(source.datum_element_container).data(topojson.feature(json, json_objs).features).enter().append("path").attr("class", source.datum_class_name).attr("d", this.path));
    }
    return _results;
  };

  return Choropleth;

})();
